Medición del tamaño de las escrituras
El primer experimento consiste en abrir un flujo al archivo fifo en /dev, efectuar 16 operaciones fwrite() con tamaños de bloques crecientes en potencias de 2, y luego efecutar fclose(). Paralelamente a todas las pruebas se está ejecutando un proceso consumidor que constantemente está leyendo el archivo fifo.
	Una vez realizada la primer prueba, cuando inspeccionamos los mensajes del módulo observamos que los paquetes de bytes que llegan al módulo no coinciden en tamaño y orden a los paquetes que han sido enviados desde el espacio de usuario. Para explicar esto, nos servimos de la documentación de la libc, apartado 12.20 "Stream Buffering", donde se menciona que "[...]los caracteres que son escritos en un flujo son acumulados y transmitidos asincrónicamente al archivo, en bloques, en vez de aparecer tan pronto como son enviados desde la aplicación[...]", en el espacio de usuario en este caso. Este mecanismo de "buffering" se emplea en flujos "fully buffered", según explica la libc. Un stream recién abierto es normalmente "fully buffered", como el caso del flujo que abrimos hacia el archivo fifo.
	Notamos que con frecuencia se envían paquetes de 4096 bytes. Podríamos considerar que el tamaño del buffer, entre la aplicación en el espacio de usuario y el archivo fifo, es de esa cantidad de bytes. Esto en consideración de que cuando el buffer está lleno y se intenta efectuar un output, este se vacía automáticamente sobre el archivo (documentación de la libc, apartado 12.20.2 "Flushing Buffers"). Las otras circunstancias en las que se vacía automáticamente el buffer no se aplican en esta situación. Sin embargo cerca de la finalización de la prueba, cuando desde el espacio de usuario se están enviando bloques de 2048 bytes o más, el tamaño de los bloques que llegan al dispositivo fifo varía entre 4096 y 61440 bytes. No encontramos información en la documentación de la libc para explicar esto.
	Si efectuamos la sumatoria del tamaño de los sucesivos paquetes que van llegando al módulo, obtenemos 131071 bytes. Es lo esperado.

El segundo experimento consistía en efectuar una operación fflush() luego de cada fwrite(). Para paquetes de entre 1 byte y 4096 bytes el resultado es el esperado: para una operación fwrite() de n bytes, en el módulo se recibe un paquete de n bytes, con 1 <= n <= 4096. Pero a partir de ese momento en adelante, la operación fflush() pareciera no tener efecto y se siente el mecanismo de buffering funcionando como en la prueba anterior. Pues el dispositivo fifo comienza a recibir paquetes de entre 4096 y 61440 bytes.
	En la página http://www.conclase.net/c/librerias/funcion.php?fun=fflush encontramos una posible explicación a esto: si el argumento de fflush apunta a un flujo de salida cuya operación más reciente era de entrada, entonces el comportamiento no está definido. Queda sin embargo por averiguar cual es la relación entre el comportamiento no definido de fflush y el tamaño de los bloques que se reciben en el modulo, los cuales coinciden con los del experimento anterior, en el que no se empleaba fflush.
	Se efectuó la sumatoria de los bytes de cada paquete, y se obtiene la suma correcta: 131071 bytes.

El resultado del tercer experimento es más fácil de interpretar: para cada fwrite() con un paquete de n bytes, se recibe en el dispositibo un paquete de igual tamaño. Esto sucede a raíz de que luego de cada fwrite() se cierra el stream, provocando que cualquier bloque de datos en el buffer se escriba obligadamente en el archivo de salida (documentación de la libc, apartado 12.4 "Closing Streams"). Así el dispositivo recibe los bloques de n bytes, con n, potencias crecientes de 2, del mismo modo en el que se envían desde el espacio de usuario.

Medición de tasa de transferencia

Sobre la primer prueba:
	las tasas de transferencia no guardan relación. Esto se puede explicar considerando lo expuesto en los experimentos anterior: cuando se llama a fwrite no se envía el paquete de información directamente al módulo si no que se almacena en un buffer intermedio primero, y luego, de ocurrir determinados eventos, se vacía el buffer en el archivo fifo. Así para los paquetes donde se midió una tasa de transferencia mayor, podríamos considerar que la información se quedó en el buffer, fwrite retorno y ahí se midió el tiempo de finalización de la prueba, dando un tiempo menor, que derivó en una tasa de transferencia mayor. Para los paquetes que dió una tasa menor, podría haber ocurrido que con mayor frecuencia, la llamada fwrite correspondiente estuviera seguida de un vaciado del buffer sobre el archivo, antes de que retorne la función, dando una medición de tiempo mayor.
	Para los paquetes de menor tamaño las tasas de transferencia fueron aumentando a medida que se repetía más veces el experimento. Esto es de esperar pues se consigue suavizar el efecto del ruido al aumentar la cantidad de repeticiones de las pruebas, mejorando el tiempo promedio, con lo que aumenta la tasa de transferencia medida. Para los paquetes de mayor tamaño la tasa de transferencia fue aumentando en algunos casos y disminuyendo en otros. De todos modos, esto no nos indica algo en particular por la aleatorealidad de los eventos que influyen en el vaciado automático del buffer, lo que esencialmente afeta en el tiempo medido.

Sobre la segunda y tercer prueba:
	A medida que aumentamos la cantidad de repeticiones del experimento, las tasas de transferencia medidas van disminuyendo y se van aproximando entre sí, particularmente para paquetes de tamaño mayor. En la segunda prueba efectuamos un fwrite seguido de fflush, y en la tercer prueba abrimos el archivo, escribimos y cerramos en cada iteración. Esto provoca un retraso, y entonces una tasa de transferencia menor.


Equipo sobre el que se corrieron las pruebas:
    *  Versión de kernel: 2.6.24-19-generic
    * Versión de libc: 2.7-10ubuntu3
    * Modelo y velocidad del microprocesador: AMD Athlon(tm) 64 Processor 3200+ - 2010.041
    * Cantidad de memoria RAM: 1028924 kB